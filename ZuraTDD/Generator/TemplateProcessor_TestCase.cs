using ZuraTDD.Generator.DataModel;
using System.Linq;

namespace ZuraTDD.Generator;

internal partial class TemplateProcessor
{
	public static string PrepareTestCaseClassCode(TestCaseSpecification testCase)
	{
		var services = testCase.ServicesClass.Services;
		var constructorArgs = string.Join(",", services.Select(s => $"\n\t\t\tthis.Services.{s.ServicePropertyName}"));

		var receives = testCase.Methods.Select(method => Functions.PrepareReceivesCode(testCase, method));
		var receivesCode = string.Join("\n\n", receives);

		var whenServices = testCase.ServicesClass.Services.Select(Functions.PrepareServiceWhenCode);
		var whenCode = string.Join("\n\n", whenServices);

		var expectServices = testCase.ServicesClass.Services.Select(Functions.PrepareExpectServiceCode);
		var expectServicesCode = string.Join("\n\n", expectServices);

		// TODO: the class should match whatever access modifiers are used in their declaration
		return
			$$"""
			// <auto-generated />
			#nullable enable
			using System;
			using System.Collections.Generic;
			using System.Threading;
			using ZuraTDD;

			namespace {{testCase.OutputNamespace}};

			/// <summary>
			/// Implementation of the test case for <see cref="{{testCase.TestSubjectClassName}}" />.
			/// Import this class with "using static {{testCase.OutputNamespace}}.{{testCase.TestCaseClassName}};"
			/// in order to simplify access to "Receives", "When" and "Expect" static classes.
			/// </summary>
			internal partial class {{testCase.TestCaseClassName}}
				: TestCase<{{testCase.TestSubjectFullyQualifiedClassName}}, {{testCase.ServicesClass.ServicesClassName}}>
			{
				public {{testCase.TestCaseClassName}}(
					string name,
					params ITestPart[] testParts)
					: base(name, testParts)
				{
				}

				/// <summary>
				/// Gets an instance of the class being tested.
				/// </summary>
				public override {{testCase.TestSubjectFullyQualifiedClassName}} GetTestSubject()
				{
					return new {{testCase.TestSubjectFullyQualifiedClassName}}({{constructorArgs}});
				}

				/// <summary>
				/// A static class creating method calls for the tested object.
				/// </summary>
				internal static class Receives
				{
			{{receivesCode}}
				}

				/// <summary>
				/// A static class creating behaviors for the tested object's dependencies.
				/// </summary>
				internal static class When
				{
			{{whenCode}}
				}

				/// <summary>
				/// A static class creating expectations which must be satisfied after the tested method completes.
				/// </summary>
				internal static class Expect
				{
					public static ITestResultExpectation ExceptionToBeThrown<TException>()
						where TException : Exception
					{
						return new ExpectedException<TException>();
					}

					public static ITestResultExpectation ResultMatching<TResult>(Predicate<TResult> predicate)
					{
						return new ExpectedResultMatching<TResult>(predicate);
					}

					public static ITestResultExpectation ResultEqualTo<TResult>(TResult expectedValue)
					{
						return new ExpectedResultMatching<TResult>(value => value!.Equals(expectedValue));
					}

			{{expectServicesCode}}
				}
			}
			""";
	}
}

static file class Functions
{
	public static string PrepareReceivesCode(
		TestCaseSpecification testCase,
		MethodSpecification method)
	{
		var parameterDeclarations = method.Parameters.Select(p => $"{p.Type}? {p.Name} = default");
		var parameterList = string.Join(", ", parameterDeclarations);

		var parameterNames = method.Parameters.Select(p => p.Name);
		var parameterValues = string.Join(", ", parameterNames);

		return
			$$"""
					/// <summary>
					/// Defines a call to the {{method.MethodName}} method.
					/// </summary>
					public static {{method.PrepareReceiveSpecificationType()}}
						{{method.MethodName}}({{parameterList}})
					{
						#pragma warning disable CS8604
						return new (
							obj => (obj as {{testCase.TestSubjectClassName}})!.{{method.MethodName}}({{parameterValues}}));
						#pragma warning restore CS8604
					}
			""";
	}

	public static string PrepareServiceWhenCode(ServiceSpecification service)
	{
		return
			$$"""
					/// <summary>
					/// A builder producing behaviors for <see cref="{{service.DeclaringNamespace}}.{{service.ServiceTypeName}}" />
					/// which will be passed as "{{service.ServicePropertyName}}" to the test subject.
					/// </summary>
					internal static {{service.ServiceTypeName}}_StaticBuilder {{service.ServicePropertyName}}
						=> new {{service.ServiceTypeName}}_StaticBuilder("{{service.ServicePropertyName}}");
			""";
	}

	public  static string PrepareExpectServiceCode(ServiceSpecification service)
	{
		return
			$$"""
					/// <summary>
					/// A builder producing expectations for <see cref="{{service.DeclaringNamespace}}.{{service.ServiceTypeName}}" />
					/// which will be passed as "{{service.ServicePropertyName}}" to the test subject.
					/// </summary>
					internal static {{service.ServiceTypeName}}_ExpectStaticBuilder {{service.ServicePropertyName}}
						=> new {{service.ServiceTypeName}}_ExpectStaticBuilder("{{service.ServicePropertyName}}");
			""";
	}
}
